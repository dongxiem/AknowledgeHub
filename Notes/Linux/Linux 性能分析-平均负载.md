# 平均负载简单例子



执行 top 或者 uptime 命令都可以在 Linux 系统中了解到负载情况：

```
$ uptime
02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88
```



一些解释如下：

```
02:34:03              //当前时间
up 2 days, 20:14      //系统运行时间
1 user                //正在登录用户数 

load average: 0.63, 0.83, 0.8   // 过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。

```



也可以使用：`watch -d uptime`，进行平均负载的变化情况查看；



# 平均负载的解释

**平均负载**是指单位时间内，系统处于可运行状态和不可中断状态的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。



关于可运行状态和不可中断状态：

- 所谓可运行状态的进程，是指正在使用 CPU 或者正在等待 CPU 的进程，也就是我们常用<u> ps 命令看到的，处于 R 状态（Running 或 Runnable）的进程</u>。

- 不可中断状态的进程则是正处于内核态关键流程中的进程，并且这些流程是不可打断的，比如最常见的是等待硬件设备的 I/O 响应，也就是我们在 <u>ps 命令中看到的 D 状态（Uninterruptible Sleep，也称为 Disk Sleep）的进程</u>。比如，当一个进程向磁盘读写数据时，为了保证数据的一致性，在得到磁盘回复前，它是不能被其他进程或者中断打断的，这个时候的进程就处于不可中断状态。如果此时的进程被打断了，就容易出现磁盘数据与进程数据不一致的问题。所以，**<u>不可中断状态实际上是系统对进程和硬件设备的一种保护机制</u>**。



也可以简单理解为：**<u>平均负载其实就是平均活跃进程数</u>**。平均活跃进程数，直观上的理解就是单位时间内的活跃进程数，但它实际上是活跃进程数的指数衰减平均值。



PS ：可以通过执行 man uptime 命令，来了解平均负载的详细解释。



最理想状态：平均负载指的是活跃进程数，那么最理想状态是每个 CPU 上都刚好运行着一个进程，这样每个 CPU 都得到了充分利用。



举个例子：当平均负载为 2 时，意味着什么呢？

- 在只有 2 个 CPU 的系统上，意味着所有的 CPU 都刚好被完全占用。

- 在 4 个 CPU 的系统上，意味着 CPU 有 50% 的空闲。

- 而在只有 1 个 CPU 的系统中，则意味着有一半的进程竞争不到 CPU。



# 平均负载的合理数



所以：可以根据 CPU 个数进行判断，**<u>当平均负载比 CPU 个数还大的时候，系统已经出现了过载</u>**。那么已经知道平均负载最理想的情况是等于 CPU 个数，在 Linux 系统中如何知道 CPU 个数：通过 top 命令或者从文件 /proc/cpuinfo 中读取：

```
$ grep 'model name' /proc/cpuinfo | wc -l
2
```



平均负载有三个数值该如何参考？

- 如果 1 分钟、5 分钟、15 分钟的三个值基本相同，或者相差不大，那就说明系统负载很平稳。

- 但如果 1 分钟的值远小于 15 分钟的值，就说明系统最近 1 分钟的负载在减少，而过去 15 分钟内却有很大的负载。

- 反过来，如果 1 分钟的值远大于 15 分钟的值，就说明最近 1 分钟的负载在增加，这种增加有可能只是临时性的，也有可能还会持续增加下去，所以就需要持续观察。一旦 1 分钟的平均负载接近或超过了 CPU 的个数，就意味着系统正在发生过载的问题，这时就得分析调查是哪里导致的问题，并要想办法优化了。



举个例子：假设我们在一个单 CPU 系统上看到平均负载为 1.73，0.60，7.98，那么说明在过去 1 分钟内，系统有 73% 的超载，而在 15 分钟内，有 698% 的超载，从整体趋势来看，系统的负载在降低。



在实际生产环境中，**平均负载多高时，需要我们重点关注呢？** 一般来说当平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的问题了。**<u>一旦负载过高，就可能导致进程响应变慢，进而影响服务的正常功能</u>**。





# 平均负载与 CPU 使用率



既然平均负载代表的是活跃进程数，那平均负载高了，不就意味着 CPU 使用率高吗？



注意：**<u>平均负载是指单位时间内，处于可运行状态和不可中断状态的进程数</u>**。所以，它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。



而 CPU 使用率，是单位时间内 CPU 繁忙情况的统计，跟平均负载并不一定完全对应。比如：

- CPU 密集型进程，使用大量 CPU 会导致平均负载升高，此时这两者是一致的；

- I/O 密集型进程，等待 I/O 也会导致平均负载升高，但 CPU 使用率不一定很高；

- 大量等待 CPU 的进程调度也会导致平均负载升高，此时的 CPU 使用率也会比较高。



# 平均负载过高时，如何调优



首先了解两个指令：stress 和 sysstat。

- stress 是一个 Linux 系统压力测试工具，可用作异常进程模拟平均负载升高的场景。

- sysstat 包含了常用的 Linux 性能工具，可用来监控和分析系统的性能。而这个包还包含两个命令 mpstat 和 pidstat。
  
  - mpstat 是一个常用的多核 CPU 性能分析工具，用来实时查看每个 CPU 的性能指标，以及所有 CPU 的平均指标。
  
  - pidstat 是一个常用的进程性能分析工具，用来实时查看进程的 CPU、内存、I/O 以及上下文切换等性能指标。



## 场景一：CPU 密集型进程



比如多核 CPU 中其中一个 CPU 使用率为 100%，可以使用 mpstat 查看 CPU 使用率的变化情况：

```
# -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据
$ mpstat -P ALL 5
Linux 4.15.0 (ubuntu) 09/22/18 _x86_64_ (2 CPU)
13:30:06     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13:30:11     all   50.05    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00   49.95
13:30:11       0    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00  100.00
13:30:11       1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
```



解释如下：可观察到有一个 CPU 的使用率为 100%，但它的 iowait 只有 0。这说明，平均负载的升高正是由于 CPU 使用率为 100% 。



然后**<u>使用 pidstat 来查询是哪个进程导致了 CPU 使用率为 100%</u>**：

```
# 间隔5秒后输出一组数据
$ pidstat -u 5 1
13:37:07      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress
```



## 场景二：I/O 密集型进程



I/O 密集型使用 mpstat 查看 CPU 使用率的变化情况：

```
# 显示所有CPU的指标，并在间隔5秒输出一组数据
$ mpstat -P ALL 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13:41:33     all    0.21    0.00   12.07   32.67    0.00    0.21    0.00    0.00    0.00   54.84
13:41:33       0    0.43    0.00   23.87   67.53    0.00    0.43    0.00    0.00    0.00    7.74
13:41:33       1    0.00    0.00    0.81    0.20    0.00    0.00    0.00    0.00    0.00   98.99
```



解释如下：1 分钟的平均负载会慢慢增加到 1.06，其中一个 CPU 的系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，<u>平均负载的升高是由于 iowait 的升高</u>。



也同样使用 pidstat 来查询是哪个进程导致 iowait 这么高的。



## 场景三：大量进程的场景



注意：当系统中运行进程超出 CPU 运行能力时，就会出现等待 CPU 的进程。



此时可以运行 pidstat 来看一下进程的情况：

```
# 间隔5秒后输出一组数据
$ pidstat -u 5 1
14:23:25      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
14:23:30        0      3190   25.00    0.00    0.00   74.80   25.00     0  stress
14:23:30        0      3191   25.00    0.00    0.00   75.20   25.00     0  stress
14:23:30        0      3192   25.00    0.00    0.00   74.80   25.00     1  stress
14:23:30        0      3193   25.00    0.00    0.00   75.00   25.00     1  stress
14:23:30        0      3194   24.80    0.00    0.00   74.60   24.80     0  stress
14:23:30        0      3195   24.80    0.00    0.00   75.00   24.80     0  stress
14:23:30        0      3196   24.80    0.00    0.00   74.60   24.80     1  stress
14:23:30        0      3197   24.80    0.00    0.00   74.80   24.80     1  stress
14:23:30        0      3200    0.00    0.20    0.00    0.20    0.20     0  pidstat
```



解释如下：8 个进程在争抢 2 个 CPU，每个进程等待 CPU 的时间（<u>代码块中的 %wait 列</u>）高达 75%。这些超出 CPU 计算能力的进程，最终导致 CPU 过载。




